Thread - A lightweight unit of execution within a process allows to perform multiple tasks concurrently
Process - An independent program with its own memory space

Memory Management
Processes have separate memory space
Threads within the same process share memory, allowing efficient data sharing but requiring careful synchronization
Resource Consumption
Creating a new process is computationally expensive and requires significant system resources
Threads are lightweight and can be created and destroyed quickly with minimum overhead
Communication
Processes communicate through complex mechanisms
Threads can communicate directly by sharing memory

Creating Threads -> ThreadsDemo.ThreadCreation
extending the Thread class
implementing Runnable interface

Callable -> ThreadsDemo.CallableDemo
unlike Runnable, Callable returns results and throws checked exceptions. Callable works with Future objects to retrieve
results after task completion. It works with ExecutorService framework rather than directly extending Thread

Runnable vs Callable
Runnable cannot return result and throw exceptions while Callable can
run() should be implemented for Runnable, call() should be implemented for Callable
Runnable works with Thread whereas Callable works with ExecutorService and Future

start() vs run() -> ThreadsDemo.RunVsStart
directly calling run will not create a new thread, it will execute in the current thread
also we cannot thread.start() more than once

Thread safety
refers to the code that functions correctly during simultaneous execution by multiple threads
it can be achieved through
synchronization
immutable objects
concurrent collections
atomic variables

sleep() vs wait()
sleep() causes the current thread to pause for a specified time without realising locks
wait() causes the current thread wait until another thread invokes notify() or notifyAll() on the same object, and it
releases the lock on the object

ThreadPools - ThreadsDemo.FixedThreadPoolDemo
are managed collection of reusable threads designed to execute tasks concurrently
Explanation from example
Executors.newFixedThreadPool(3) creates a pool with 3 reusable threads.
Five tasks are submitted. Since only 3 threads exist, the first 3 tasks start immediately.
As tasks complete, the available threads pick up the remaining tasks.
Threads are reused, avoiding the overhead of creating new threads for each task. After task completion, the thread
returns to the pool (RUNNABLE state waiting for next task)
The execution order may vary based on CPU scheduling.
Pool Shutdown: During shutdown, threads complete their current tasks and are eventually terminated.

Executors.newCachedThreadPool()
Threads are created dynamically as needed, avoiding delays due to waiting.

ThreadPoolExecutor
It provides a thread pool implementation for executing tasks concurrently.
It’s the backbone of most thread pools created via Executors factory methods (like Executors.newFixedThreadPool()).
ThreadsDemo.ThreadPoolExecutorDemo
Core size = 2 → first 2 tasks get threads immediately.
Queue size = 2 → next 2 tasks go into queue.
Max size = 4 → 2 more tasks can start new threads.
If more tasks are submitted → rejected